#!/usr/bin/env ruby

require 'thor'
require 'securerandom'
require 'pp'
require_relative '../lib/hyperledger_cli'
require_relative '../lib/hyperledger_cli/key'

include HyperledgerCli

class Asset < Thor
  
  desc 'list', 'List all known assets'
  def list
    response = get("#{options[:server]}/ledgers")
    pp response
  end
  
  desc 'register <hash>', 'Registers a new asset. The hash must be an unique hex encoded SHA265 hash.'
  def register(hash)
    asset_key = Key.new
    primary_account_key = Key.new
    data = {
      ledger: {
        publicKey: asset_key.public_key,
        hash: hash,
        primaryAccountPublicKey: primary_account_key.public_key
      }
    }
    
    response = post("#{options[:server]}/ledgers", data, asset_key)
    puts 'New asset created'
    pp response
    
    asset_key.write
    primary_account_key.write
  end
end

class Account < Thor
  desc 'list', 'List all known accounts'
  def list
    response = get "#{options[:server]}/accounts"
    pp response
  end
  
  desc 'register <asset>', 'Registers a new account to hold <asset>.'
  def register(asset)
    account_key = Key.new
    data = {
      account: {
        ledgerHash: asset,
        publicKey: account_key.public_key
      }
    }
    
    response = post("#{options[:server]}/accounts", data, account_key)
    puts 'New account created'
    pp response
    account_key.write
  end
end

class Hyperledger < Thor
  class_option :server, type: :string
  
  desc 'asset SUBCOMMAND', 'Subcommands relating to ledgers.'
  subcommand 'asset', Asset
  
  desc 'account SUBCOMMAND', 'Subcommands relating to accounts.'
  subcommand 'account', Account
  
  desc 'issue <amount> <asset>', 'Issue <amount> new units of <asset>.'
  def issue(amount, asset, public_key)
    ledger_key = Key.new(public_key)
    data = {
      issue: {
        uuid: SecureRandom.uuid,
        ledgerHash: asset,
        amount: amount.to_i
      }
    }
    
    response = post "#{options.server}/ledgers/#{asset}/issues", data, ledger_key
    puts 'Issue completed!'
    pp response
  end
  
  desc 'transfer <amount> <source> <destination>', 'Transfer <amount> of units from <source> to <destination>'
  def transfer(amount, source, destination)
    source_key = Key.new(source)
    data = {
      transfer: {
        uuid: SecureRandom.uuid,
        sourcePublicKey: source,
        destinationPublicKey: destination,
        amount: amount.to_i
      }
    }
        
    response = post "#{options.server}/transfers", data, source_key
    puts 'Transfer completed!'
    pp response
  end
end

Hyperledger.start(ARGV)
